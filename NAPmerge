#!/usr/bin/env perl
#By Thomas J Creedy, thomas@tjcreedy.co.uk



use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy qw(move);
use List::Util qw(all any max); 
use Algorithm::Loops qw(NestedLoops);
use Parallel::ForkManager;
use Time::HiRes qw(usleep);
####Dev####
use Data::Dumper;

my $version = "0.3.2"; #07/11/2018
my $help;
my $outpath;
my %parameters;
my %itsx;
my %primers;
my $mode = "run";
our $verbose;
my $threads = 1;
our $debug;

my $script = basename($0,());

########################################################
# USAGE
#
my $usage =<<USAGE;

Description:

	This is $script version $version of the NGS Amplicon Pipeline. It takes in a pair or set of paired files, such as those output from NAPdemux, and carries out a sequence of processes by calling external programs:
		# Primer trimming - removes specified number of bases from F and R reads
		# Merging - combining overlapping read pairs
		# Filtering - removing poor quality reads 
		# ITSx filtering - searching for fungal sequences (OPTIONAL)
		# Read naming - adding the sample name to every read for future clustering and mapping
	The script can run with each parameter specified with a single value, in which case it outputs a fasta for each pair of fastq files, or if parameter ranges are specified it will loop through every combination of all parameters and output a log table with the results

Usage:

	Default mode
	$script -o <dir> -f <n> -r <n> -p <n> -e <n> [-itsx <path/to/HMMs>] [-t <n>] [-v] <inputfqs>
	
	Evaluation mode
	$script -o <dir> -f <n> -r <n> -p <n-n,n> -e <n-n,n> --mode eval [-itsx <path/to/HMMs>] [-t <n>] [-v] <inputfqs>

Arguments:

	       outpath:  Path to a directory in which output files and the log table are written.
	forwardprimerl:  Number of bases to trim from the forward reads.
	reverseprimerl:  Number of bases to trim from the reverse reads.
	   pearquality:  A value or range to pass to PEAR as a -q option.
	         eemax:  A value or range to pass to USEARCH70 fastq_filter as a -fastq_maxee option
	          mode:  One of "run" or "eval", see above. Default "run".
	          itsx:  If ITSx is required, the path to HMMs to pass to the function. Optional.
	    taxon_itsx:  If ITSx is used, the taxon or taxa (according to the ITSx requirements) to filter for. Required if using ITSx.
	   region_itsx:  If ITSx is used, the region (according to the ITSx requirements) to filter for. Currently, only one region is accepted. Default "ITS2".
	       threads:  Number of CPU threads to use. Default 1.
	       verbose:  Reports on progress.
	          help:  Prints out this helpful message.

USAGE
#
######################################################

GetOptions("outpath=s"		=> \$outpath,
	   "forwardprimerl=i"	=> \$primers{length}{forward},
	   "reverseprimerl=i"	=> \$primers{length}{reverse},
	   "Fprimersequence=s"	=> \$primers{sequence}{forward},
	   "Rprimersequence=s"	=> \$primers{sequence}{reverse},
	   "Primersfile=s"	=> \$primers{sequence}{file},
	   "Stricttrim"		=> \$primers{sequence}{strict},
	   "pearquality=s"	=> \$parameters{pearquality},
	   "eemax=s"		=> \$parameters{eemax},
	   "mode=s"		=> \$mode,
	   "noconvert"		=> \$parameters{noconvert},
	   "itsx=s"		=> \$itsx{path},
	   "taxon_itsx=s"	=> \$itsx{taxon},
	   "region_itsx=s"	=> \$itsx{region},
	   "threads=i"		=> \$threads,
	   "verbose"		=> \$verbose,
	   "debug"		=> \$debug,
	   "help"		=> \$help) or die "Error: Incorrect options, try \"$script --help\" for more information.\n";

########################################################
# HEADER
#
my $timedate = timestamp()." ".datestamp();
my $timer = "100000";
my $title =<<TITLE;
  _   _          _____  _   _                 
 | \\ | |   /\\   |  __ \\| | (_)                
 |  \\| |  /  \\  | |__) | |_ _ _ __ ___   ___  
 | . ` | / /\\ \\ |  ___/| __| | '_ ` _ \\ / _ \\ 
 | |\\  |/ ____ \\| |    | |_| | | | | | |  __/ 
 |_| \\_/_/    \\_\\_|     \\__|_|_| |_| |_|\\___| 
TITLE
foreach my $line (split '\n',$title){
	print $line,"\n";
	usleep($timer);
}

print "\nWelcome. This is $script version $version, started at $timedate.\n";

print "$usage\n" and exit if($help);

$verbose = 1 if $debug;
print "\n#### Running in debug mode ####\n\n" if $debug;

print "\nChecking your parameters...\n";

if(scalar @ARGV == 0){
	if($debug){
		warn "No input files, running for debug purposes only. There may be errors.\n";
	} else {
		die "I need me some files to work on, see \"$script --help\" for more information\n";
	}
}

#
#
########################################################

die "Error: please specify --pearquality, see \"$script --help\" for more information\n" if(!defined $parameters{pearquality});
die "Error: please specify --eemax or --noconvert, see \"$script --help\" for more information\n" if(!defined $parameters{eemax}&!$parameters{noconvert});

die "Error: please specify -taxon_itsx if using ITSx, see \"$script --help\" for more information\n" if($itsx{path} and !$itsx{taxon});

print "DEBUG: itsx hash:\n",Dumper\%itsx if $debug;

if(defhash(\%itsx)){
	die "Error: you must specify a path to HMMs using -itsx if you wish to use ITSx, see \"$script --help\" for more information\n" unless $itsx{path};
	if($itsx{taxon}){
		print "ITSx taxon $itsx{taxon} requested: note that $script does not check that this is an acceptable value for ITSx\n";
	} else {
		$itsx{taxon} = '.';
	}
	if($itsx{region}){
		my %permitted_regions = map { $_ => 1 } ("SSU","ITS1","5.8S","ITS2","LSU");
		die "Error: please specify a single accepted region for -region_itsx, see \"$script --help\" for more information\n" unless $permitted_regions{$itsx{region}};
	} else {
		$itsx{region} = "ITS2";
	}
}

print "DEBUG: primers hash:\n", Dumper \%primers if $debug;

if(defhash(\%{$primers{length}})){
	die "Error: please specify either primer lengths or primer sequences for trimming, not both, see \"$script --help\" for more information\n" if defhash(\%{$primers{sequence}});
	die "Error: you must specify the lengths of both forward and revers primers for length trimming, see \"$script --help\" for more information\n" unless ($primers{length}{forward} and $primers{length}{reverse});
} elsif(defhash(\%{$primers{sequence}})){
	if($primers{sequence}{file}){
		die "Error: please specify either both primer sequences or the path to a file containing primer sequences, see \"$script --help\" for more information\n" if( $primers{sequence}{forward} or $primers{sequence}{reverse} );
		$primers{sequence}{forward} = line($primers{sequence}{file},1) or die "Error: cannot read or parse primer file\n";
		$primers{sequence}{reverse} = line($primers{sequence}{file},2) or die "Error: cannot read or parse primer file\n";
	} else {
		die "Error: please specify both forward and reverse primer sequences, see \"$script --help\" for more information\n" unless( $primers{sequence}{forward} and $primers{sequence}{reverse} );
	}
	print "Warning: reads with poor adapter matches will not be trimmed, but will be retained in the dataset, if -Stricttrim is not set, see \"$script --help\" for more information\n" unless $primers{sequence}{strict}
} else {
	die "Error: please specify some primer details, either lengths or sequences, see \"$script --help\" for more information\n";
}

#print "DEBUG: primers hash:\n", Dumper \%primers if $debug;

if(!defined $outpath){
	die "Error: output directory must be specified, see \"$script --help\" for more information\n";
} else {
	make_path($outpath);
}

print "\nChecking your files...\n";

my @files=@ARGV;

my %paired_files = find_pairs(@files);
my $n_file_pairs = keys %paired_files;

print "\nParsing iterations...\n";

print "DEBUG: Input parameters:\n",Dumper \%parameters if $debug;

if($parameters{noconvert}){
	die "Error: cannot run ITSX if not converting reads to fasta\n" if $itsx{path};
	$parameters{noconvert} = "true";
	warn "Warning: values for eemax parameter are superfluous when not converting to fastq\n" if($parameters{eemax});
	$parameters{eemax} = "NA";
} else {
	$parameters{noconvert} = "false";
}

print "DEBUG: Filtered parameters for parsing:\n", Dumper \%parameters if $debug;

my $iterations = parse_parameters($mode,\%parameters,sort keys %paired_files);

print "DEBUG: Parsed iterations:\n", Dumper $iterations if $debug;

print "\nSetting up directories...\n";

make_path("$outpath/trim");

my %report; # Report hash

print "\nPreparing for trimming...\n";
# Run trimming

my $tpm = Parallel::ForkManager->new($threads);

my $done_trims=0;
my %trim_log;

$tpm->run_on_finish( sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
	$done_trims++;
	printf "Completed trimming $done_trims/%d file pairs\r", scalar keys %paired_files if $verbose;
	my $fork_name = $data_structure_reference->{name};
	$trim_log{$fork_name} = $data_structure_reference->{result};
});

printf "Starting to trim %d file pairs using $threads threads\n", scalar keys %paired_files if $verbose;

foreach my $name (sort keys %paired_files){
	my $pid = $tpm->start and next;
	
	my $out = trim(\%paired_files,$name,\%primers,$outpath);
	
	$tpm->finish(0, {result => $out, name => $name});
}

$tpm->wait_all_children;
print "\n";


# Run merging
my $mpm = Parallel::ForkManager->new($threads);

my $done_iterations=0;

$mpm->run_on_finish( sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
	$done_iterations++;
	printf "Completed $done_iterations/%d iterations\r", scalar keys %$iterations if $verbose;
	my $iteration = $data_structure_reference->{iteration};
	$report{$iteration} = $data_structure_reference->{result};
});

printf "Starting %d merging and filtering iterations using $threads threads\n", scalar keys %$iterations if $verbose;

foreach my $iter (sort keys %$iterations){
	my $pid = $mpm->start and next;
	
	my $out = merge_iteration($iterations,$iter,\%trim_log,\%itsx,$outpath,$mode);
	
	$mpm->finish(0, {result => $out, iteration => $iter});
}

$mpm->wait_all_children;
print "\n";
remove_tree("$outpath/trim") unless $debug;

#Do logging
open my $log, '>', "$outpath/merge.log.csv" or die "Error opening csv log for writing"; #open csv object for writing, and name

print $log join(',',('readname' , 'iteration' ,'Input_reads','Pairs_untrimmed_removed', 'pearquality' , 'pcA' , 'pcC' , 'pcG' , 'pcT' , 'uncalled_bases' , 'PEAR_total_reads' , 'PEAR_merged_reads' , 'PEAR_discarded_reads' , 'PEAR_not_merged_reads' ,'Max_expected_E-value', 'Filter_total_reads' , 'Filter_discarded' , 'Filter_converted','ITSx detected')),"\n";

foreach my $i (sort keys %report){
	print $log $report{$i};
}

close $log;

print "CSV log of read processing written \n" if($verbose);


exit;

#Create a hash of iterations, each of which is a hash of parameters and their values for that iteration

sub trim {
	my ($pairs,$name,$primers,$outpath) = @_;
	my $cutspec;
	my $log;
	
	if(defhash(${$primers}{length})){
		print "Trimming file pair $name based on primer lengths\n" if $verbose;
		$cutspec = "-u ${$primers}{length}{forward} -U ${$primers}{length}{reverse}";
	} else {
		print "Trimming file pair $name based on primer sequences\n" if $verbose;
		$cutspec = "-g ${$primers}{sequence}{forward} -G ${$primers}{sequence}{reverse}";
		$cutspec .= " --discard-untrimmed" if ${$primers}{sequence}{strict};
	}
	
	my $cutadapt_cmd = "cutadapt $cutspec --minimum-length 1 --pair-filter any -o $outpath/trim/$name\_R1.fq -p $outpath/trim/$name\_R2.fq ${$pairs}{$name}[0] ${$pairs}{$name}[1]";
	
	print "DEBUG: cutadapt command:\n$cutadapt_cmd\n" if $debug;
	
	my $cutadapt_log = `$cutadapt_cmd`;
	
	
	print "DEBUG: cutadapt log:\n$cutadapt_log\n" if $debug;
	
	$cutadapt_log =~ /Total read pairs processed:[^\d]+(\d{1,3}(?:,\d{3})*)[^\d].*\(passing filters\):[^\d]+(\d{1,3}(?:,\d{3})*)[^\d]/s;
	my @cutadapt_parse = ($1,$2);
	map { s/,//g; } @cutadapt_parse;
	$cutadapt_parse[1] = $cutadapt_parse[0] - $cutadapt_parse[1];
	$log = join ",",@cutadapt_parse;
	return $log;
}

sub merge_iteration {
	my ($iterations,$iter,$trim_log,$itsx,$outpath,$mode) = @_;
	
	make_path("$outpath/merge_$iter","$outpath/filter_$iter");
	
	my $log = "${$iterations}{$iter}{name},$iter,${$trim_log}{${$iterations}{$iter}{name}},${$iterations}{$iter}{pearquality}";
	
	my $pear_cmd = "pear -f $outpath/trim/${$iterations}{$iter}{name}\_R1.fq -r $outpath/trim/${$iterations}{$iter}{name}\_R2.fq -o $outpath/merge_$iter/${$iterations}{$iter}{name} -q ${$iterations}{$iter}{pearquality} 2>/dev/null";
	
	print "Running PEAR on file ${$iterations}{$iter}{name} for iteration $iter with quality threshold ${$iterations}{$iter}{pearquality}\n" if $verbose;
	print "DEBUG: PEAR command:\n$pear_cmd\n" if $debug;
	my $asmbl_log=`$pear_cmd`;
	print "DEBUG: PEAR log:\n$asmbl_log\n" if $debug;
	$asmbl_log=~ /.*A:\s(\d.\d{6})\s*C:\s(\d.\d{6})\s*G:\s(\d.\d{6})\s*T:\s(\d.\d{6})\n\s*(\d*).*Assembled\sreads\s[\.]*:\s([\d|,]*)\s.*Discarded\sreads\s[\.]*:\s([\d|,]*)\s.*Not\sassembled\sreads\s[\.]*:\s([\d|,]*)\s\/\s([\d|,]*).*/s; #regex to extract data from pear_log
	
	my @pear_parse = ($1,$2,$3,$4,$5,$9,$6,$7,$8);
	foreach my $e (@pear_parse){
		$e =~ s/,//g;
		$log .= ",$e";
	}
	
	if (${$iterations}{$iter}{noconvert} eq "true"){
		move "$outpath/merge_$iter/${$iterations}{$iter}{name}.assembled.fastq", "$outpath/${$iterations}{$iter}{name}.fq";
		$log .= ",NA,NA,NA,NA\n";
	} else {
		$log .= ",${$iterations}{$iter}{eemax}";
		my $filter_cmd = "usearch70 -fastq_filter $outpath/merge_$iter/${$iterations}{$iter}{name}.assembled.fastq -fastaout $outpath/filter_$iter/${$iterations}{$iter}{name}.fa -fastq_maxee ${$iterations}{$iter}{eemax} 2>&1 1>/dev/null";
		
		print "Running fastq_filter on file ${$iterations}{$iter}{name} for iteration $iter with eemax ${$iterations}{$iter}{eemax}\n" if $verbose;
		my $filter_log=`$filter_cmd`; #Filter using USEARCH70 fastq_filter, saving terminal output. Note that this function outputs USEARCH70 version information to STDOUT and the actual useful information about filtering to STDERR, hence the redirect of STDERR to STDOUT and discarding of STDOUT
		
		$filter_log=~ /.*\s(\d*)\s\sFASTQ.*\s(\d*)\s\sLow.*\s(\d*)\s\sConverted.*/s; #regex to extract data
		my @fqfilter_parse = ($1,$2,$3);
		foreach my $e (@fqfilter_parse){
			$e =~ s/,//g;
			$log .= ",$e";
		}
		
		
		
		my $last = "filter_$iter/${$iterations}{$iter}{name}.fa";
		
		if(${$itsx}{path}){
			print "Running ITSx on file ${$iterations}{$iter}{name} for iteration $iter\n" if $verbose;
			
			make_path("$outpath/itsx_$iter");
			
			my $itsx_outfile = "$outpath/itsx_$iter/${$iterations}{$iter}{name}";
			
			my $itsx_cmd = "ITSx -p ${$itsx}{path} -i $outpath/filter_$iter/${$iterations}{$iter}{name}.fa -o $itsx_outfile -t ${$itsx}{taxon} --save_regions ${$itsx}{region} --preserve T --cpu 1 --graphical F --positions F --not_found F";
			print "DEBUG: ITSx command:\n$itsx_cmd\n" if $debug;
			system("$itsx_cmd");
			
			$last = "itsx_$iter/${$iterations}{$iter}{name}.${$itsx}{region}.fasta";
			
			my $summaryline = line("$itsx_outfile.summary.txt",2);
			$summaryline =~ /[^\d]+(\d{1,3}(?:,\d{3})*)$/;
			my $summary = $1;
			$summary =~ s/,//g;
			$log .= ",$summary";
			
		} else {
			$log .= ",NA";
		}
		
		$log .= "\n";
		
		my $suffix = $mode eq "eval" ? "_iteration$iter" : "";
		
		my $readlabelcmd="sed \"-es/^>\\([^ ]*\\)\\(.*\\)/>\\1;barcodelabel=${$iterations}{$iter}{name};/\" < $outpath/$last > $outpath/${$iterations}{$iter}{name}$suffix.fa"; #Append sample name to reads within paired read file. note the double escaping for sed expression within quoted string
		system($readlabelcmd);
	}
	remove_tree("$outpath/merge_$iter","$outpath/filter_$iter") unless $debug;
	remove_tree("$outpath/itsx_$iter") if $itsx and !$debug;
	return $log;
}

sub parse_parameters {
	my ($inmode, $inparams,@names) = @_;
	my @itarray;
	my @paramarray;
	my $n_singleparams;
	push @paramarray, "name";
	push @itarray, \@names;
	die "Input parameters not single values, did you mean to use \"--mode eval\"?\n" unless $inmode eq "eval" or all { $_ =~ /^[^,-]*$/ } values %$inparams;
	foreach my $param (keys %$inparams){
		push @paramarray, $param;
		if($inmode eq "run"){
			push @itarray, [$inparams->{$param}];
		} elsif ($inmode eq "eval"){
			if ($inparams->{$param} =~ /^(\d+(\.\d+)?)-(\d+(\.\d+)?),(\d+(\.\d+)?)$/ ){
				my @values;
				my $curmax = $1;
				while ($curmax <= $3){
					push @values, $curmax;
					$curmax += $5;
				}
				push @itarray, \@values;
			} elsif($inparams->{$param} =~ /^[a-zA-Z]+(?:,[a-zA-Z]+)+$/){
				my @values = split ',',$inparams->{$param};
				push @itarray, \@values;
			} elsif($inparams->{$param} =~ /^[a-zA-Z]+$|^\d+(\.\d+)?$/){
				push @itarray, [$inparams->{$param}];
				$n_singleparams++;
				die "No parameter ranges given, did you mean to use \"--mode run\"?\n" if($n_singleparams == scalar keys %$inparams);
			} else {
				die "Could not successfully parse string given for $param\n";
			}
		} else {
			die "Argument passed to --mode not recognised, see \"$script --help\" for more information\n"
		}
	}
	
	my @allarray;
	
	NestedLoops(\@itarray, sub {push @allarray, [ @_ ]});
	
	my %iterhash;
	foreach my $it (0 .. $#allarray){
		$iterhash{$it+1} = {map { $paramarray[$_] => $allarray[$it][$_] } 0..$#paramarray};
	}
	return \%iterhash;
}

sub line {
	my ($path,$line) = @_;
	open my $fh, '<', $path;
	while (<$fh>) {
		chomp $_;
		return $_ if $. == $line;
	}
}

sub find_pairs {
	my @allfiles = @_;
	my %filepairs;
	foreach my $file (@allfiles){
	    my ($file_name,$dir)=fileparse($file);
	    if($file_name =~ /(.+)_R([1|2])/){
		$filepairs{$1}[$2-1]=$file;
	    }else{
		warn "Input file $file does not contain '_R1' or '_R2' in name: $file";
	    }
	}
	return %filepairs;
}

sub defhash{
	my ($hash) = @_;
	return any { defined ${$hash}{$_} } keys %{$hash};
}

sub timestamp{
my @time = localtime;
return sprintf "%02d:%02d:%02d",$time[2],$time[1],$time[0];
}

sub datestamp{
my @time = localtime;
return sprintf "%04d-%02d-%02d",$time[5]+1900,$time[4]+1,$time[3];
}
