#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path remove_tree);
use List::Util qw(sum all any min max); 
use List::MoreUtils qw(pairwise);
use Algorithm::Loops qw(NestedLoops);
use POSIX;
use LWP::Simple;
use Parallel::ForkManager;
use Sys::Hostname;

####Dev####
use Data::Dumper;

my $version = "0.3.1"; #16/5/17

my $help;
my $outpath;
my %parameters;
my $mode;
my $display = "groups";
my $threads = 1;
our $blastpath;
our $verbose;

my $script = basename($0,());

########################################################
# USAGE
#
my $usage =<<USAGE;

Description:

	This is $script version $version of the NGS Amplicon Pipeline. It carries out either barcode selection or clustering of one or several fastas. When selecting barcodes, there are three modes: viewing statistics for a single file, running one or several files in batch mode with a set of parameters, or iterating through range(s) of parameter(s) to explore parameter space. Clustering only has the latter two modes.
	
	For more details, see the google doc documentation.
	
USAGE
#
######################################################

GetOptions("output=s"		=> \$outpath,
	   "mode=s"		=> \$mode,
	   "minlength=s"	=> \$parameters{minlength},
	   "nest"		=> \$parameters{nest},
	   "minsize=s"		=> \$parameters{minsize},
	   "bootstraps=s"	=> \$parameters{bootstraps},
	   "blasthits=s"	=> \$parameters{blasthits},
	   "blasttarget=s"	=> \$parameters{blasttarget},
	   "blastthreshold=s"	=> \$parameters{blastthreshold},
	   "pvalue=s"		=> \$parameters{pvalue},
	   "threshold_pvalue"	=> \$parameters{pvalue_maxthreshold},
	   "identitypc=s"	=> \$parameters{identity},
	   "display=s"		=> \$display,
	   "threads=i"		=> \$threads,
	   "blastpath=s"	=> \$blastpath,
	   "verbose"		=> \$verbose,
	   "help"		=> \$help) or die "Error: Incorrect options, try \"$script --help\" for more information.\n";


print "$usage\n" and exit if($help);

die "I need some files to work on, see \"$script --help\" for more information\n" if(scalar @ARGV == 0);

my @files=@ARGV;

#print Dumper \%parameters;

my %paramdefaults = (
	'nest'			=> 0,
	'minsize'		=> 2,
	'bootstraps'		=> 10000,
	'blasthits'		=> 100,
	'blastthreshold'	=> 0.2,
	'pvalue'		=> 0,
	'pvalue_maxthreshold'	=> 0.5,
	'identity'		=> 0.99,
);

#print Dumper \%paramdefaults;
my @params = ('minlength','nest','minsize','bootstraps','blasthits','blasttarget',
		'pvalue','blastthreshold','pvalue_maxthreshold','identity');

$mode = "stat" unless(defined $mode);
die "Error, BLAST target must be specified\n" if(! $parameters{blasttarget});
@parameters{@params} = map { defined $parameters{$_} ? $parameters{$_} : $paramdefaults{$_} } (@params);
print "Mode is \"batch\" but you've only given me one file. Did you mean \"--mode stat\"? Running anyway...\n" if($mode eq "batch" and scalar @files < 2);
die "Error: minlength must be specified\n" unless(defined $parameters{minlength});

#print Dumper \%parameters;

print "\nParameters parsed successfully, mode is \"$mode\"\n" if $verbose;

if(!defined $outpath){
	die "Error: output directory must be specified, see \"$script --help\" for more information\n";
} else {
	print "Creating output directory if needed\n" if $verbose;
	make_path($outpath);
	$outpath =~ s/\/$//;
}

#
# Check for blast database and arrange threads
#
if(!$blastpath){
	my $host = hostname;
	my %paths = (
		'ctag' => '/dh/blastdb/nt',
		'hpc-watson' => '/db/blastdb/nt'
	);
	if(exists($paths{$host})){
		$blastpath = $paths{$host};
	} else {
		die "Error: no path to BLAST database found, please give me one using --blastpath <path>\n";
	}
}
my $blastthreads = 1;
if($mode eq "stat"){
	$blastthreads = $threads;
} elsif(scalar @files < $threads){
	$blastthreads = floor($threads /scalar @files);
}

#
# Set up parameter iterations
#
my $iterations = parse_parameters($mode,\%parameters);

my @n_iter = sort keys %$iterations;

printf "%d iterations successfully parsed\n\n",$#n_iter+1 if($verbose and $#n_iter>0);

my ($disp_stat,$disp_n);
if ($mode eq "stat"){
	die "Error: mode \"stat\" only accepts one file and one parameter set, see \"$script --help\" for more information\n" unless ($#files == 0 && $#n_iter == 0);
	if($display eq "groups"){
		$disp_stat = "size";
	} else {
		($disp_stat,$disp_n) = split("-", $display) or die "Error parsing argument to --display\n";
		die "Error: --display $display not recognised, must be a request to display \"groups\", \"size\" or \"maxlength\"\n" unless($disp_stat eq "size" || $disp_stat eq "maxlength");
	}
} # OTHER ERROR CATCHES?


my %log;

my %stats = (
	general => ['filename','sequences','iteration','n_seq_discarded_<minlength','n_groups_discarded_<minsize','n_groups_remain'],
	group   => ['mean_groupsize','stdev_groupsize','min_groupsize','max_groupsize','max_groupsize_pc'],
	filter  => ['filteroutcome','groupselected','bootstrap_pvalue','n_groups_pooled','selected_rank','pooled_size'],
);


my $logline;
if($mode eq "stat"){
	print "\nProcessing sample\n" if $verbose;
	$log{1} = read_group_and_filter($files[0],$iterations,1,$blastthreads,\@params,\%stats);
	histograms_and_output($log{1},$disp_stat,$outpath);
} elsif($mode eq "batch" or $mode eq "eval"){
	
	my $pm = Parallel::ForkManager->new($threads);
	my $done_iterations=0;

	$pm->run_on_finish( sub {
		my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
		$done_iterations++;
		printf "Completed $done_iterations/%d total iterations\r",($#n_iter+1)*($#files+1) if $verbose;
		my $line = $data_structure_reference->{line};
		$log{$line} = $data_structure_reference->{result};
	});
	
	printf "Starting %d filtering iterations using $threads threads\n", ($#n_iter+1)*($#files+1) if $verbose;
	foreach my $file (@files){
		foreach my $iter (@n_iter){;
			my $pid = $pm->start and next;
		
			$logline++;
			my $out = read_group_and_filter($file,$iterations,$iter,$blastthreads,\@params,\%stats);
		
			$pm->finish(0, {result => $out, line => $logline});
		}
	}
	
	$pm->wait_all_children;
	print "\n";
} else {
	die "Mode not recognised\n";
}

if($mode eq 'batch' and $verbose){
	my $filtersuccesses;
	map { $filtersuccesses++ if $log{$_}{filteroutcome} eq "passed" } keys %log;
	printf "$script successfully selected sequences for $filtersuccesses of %d files with given filtering parameters, see log for details\n",scalar keys @files ;
}

#
# Output results log
#

open my $logcsv, '>', "$outpath/select.$mode.log.csv";

my @head = (@{$stats{general}},@params,@{$stats{group}},@{$stats{filter}});
print $logcsv join(',',@head);

open my $outfa, '>', "$outpath/select.sequences.fa" if($mode eq 'batch');

foreach my $i (keys %log){
	print $logcsv "\n",join(',',@{$log{$i}}{@head});
	print $outfa ">${$log{$i}}{filename}\n${$log{$i}}{sequence}\n" if($mode eq 'batch' and ${$log{$i}}{filteroutcome} eq 'passed');
}
close $logcsv;
close $outfa if($mode eq 'batch');

print "\nCSV log successfully written to $outpath/select.$mode.log.csv\n" if $verbose;
print "Fasta of selected sequences successfully written to $outpath/select.sequences.fa\n" if($mode eq 'batch' and $verbose);

##TODO: implement swarm and associated functions


exit;

sub read_group_and_filter{
	my ($file,$iterations,$iter,$blastthreads,$params,$stats) = @_;
	
	my %log;
	
	#
	# Read in fasta
	#
	my %fasta = read_fasta($file);
	my ($name,$dir)=fileparse($file);
	
	$name =~ s/^(.+)\.[^.]+$/$1/;
	warn "Warning: file $name is empty!\n" if(scalar keys %fasta < 1);
	
	##printf "\nProcessing file $i_file of %d: $name\n", $#files+1 if($verbose and $#files>0);
	printf "\nParameter iteration $iter of %d for $name\n", $#n_iter+1 if($verbose and $#n_iter>0);
	
	#
	# Grouping function
	#
	print "Grouping all sequences longer than ${$iterations}{$iter}{minlength}bp by ", ${$iterations}{$iter}{nest} ? "nested identity\n" : "identity\n" if $verbose ;
	my ($groups,$minlength_discarded,$minsize_discarded) = group(\%fasta,${$iterations}{$iter});

	#
	# Sort groups by size
	#
	my @gids = keys %$groups;
	my %groupsort;
	foreach my $g (@gids){
		$groupsort{$g} = $groups->{$g}{size};
	}
	my ($ngroup,$topsize,$totseq) = @gids ? (scalar keys %groupsort,max(values %groupsort),sum(values %groupsort)) : (0,0,0);
	printf "%d sequences grouped after $minlength_discarded discarded for being less than ${$iterations}{$iter}{minlength}bp long. $minsize_discarded groups discarded for having fewer than ${$iterations}{$iter}{minsize} sequences, %d groups remain containing %d sequences\n", @gids ? scalar keys %fasta : 0, $ngroup, $totseq if($verbose or $mode eq 'stat');

	#
	#Filtering
	#
	printf "Filtering %d groups\n", $ngroup if $verbose;
	
	my $filterresult = filter_groups($groups,${$iterations}{$iter},$stats{filter},$blastthreads);
	
	warn "Warning, BLAST failed 5 times when filtering groups for $file" if exists(${$filterresult}{blastwarning});
	
	#
	# Do logging
	#
	@log{@{${$stats}{group}}} = @gids ? ($totseq/$ngroup,stdev(values %groupsort),min(values %groupsort), $topsize,$topsize/$totseq) : ((0) x 5);
	@log{@{${$stats}{general}}} = ($name, scalar keys %fasta, $iter, $minlength_discarded, $minsize_discarded, $ngroup);
	@log{@{${$stats}{filter}}} = @{$filterresult}{@{${$stats}{filter}}};
	@log{@$params} = @{${$iterations}{$iter}}{@$params};
	
	#
	# Take actions if filtering successful
	#
	if (${$filterresult}{filteroutcome} eq 'passed'){
		print "Candidate sequence selected, see log for details\n" if $verbose;
		$log{sequence} = $groups->{$log{groupselected}}{seq};
	} else {
		print "No candidate sequence could be selected, see log for details\n" if $verbose;
		$log{sequence} = "-";
	}
	
	#
	# Record groups and return
	#
	$log{groups} = $groups;
	return \%log;
}

sub histograms_and_output{
	my ($log,$disp_stat,$outpath) = @_;
	my $groups = ${$log}{groups};
	my @gids = keys %$groups;
	
	if(@gids){
		my %groupsort;
		foreach my $g (@gids){
			$groupsort{$g} = $groups->{$g}{size};
		}
		#
		# Display histograms
		#
		my (@stat_sorted,@gids_sorted);
		if($disp_stat eq "maxlength"){
			foreach my $g (@gids){
				$groupsort{$g} = ${$groups}{$g}{maxlength};
			}
		
			@stat_sorted = sort { $b <=> $a } values %groupsort;
			@gids_sorted = sort { $groupsort{$b} <=> $groupsort{$a} } keys %groupsort;
		} else {
			@stat_sorted = sort { $b <=> $a } values %groupsort;
			@gids_sorted = sort { $groupsort{$b} <=> $groupsort{$a} } keys %groupsort;
		}
		if($display eq "groups"){
			print "Histogram of $disp_stat values for all groups\n";
			histogram (\@stat_sorted,10);
		} else {
			print "Histogram of sequence lengths within group $gids_sorted[$disp_n-1] with rank $disp_n $disp_stat value $stat_sorted[$disp_n-1]\n";
			histogram(\@{${$groups}{$gids_sorted[$disp_n-1]}{lengths}},10);
			print "Histogram of base frequencies by position within group $gids_sorted[$disp_n-1] with rank $disp_n $disp_stat value $stat_sorted[$disp_n-1]\n";
			histogram(\@{${$groups}{$gids_sorted[$disp_n-1]}{basefreq}},10);
			my @matches =  map { $stat_sorted[$disp_n-1] == $_ ? 1 : 0 } @stat_sorted;
			warn "Warning: groups of other rank have the same $disp_stat value, make sure to check a rank above and below $disp_stat if appropriate\n" if(sum(@matches)>1);
		}
	
		#
		# Write to group log and fasta
		#
		my $name = ${$log}{filename};
		print "Writing group sequences to fasta and details to log\n" if $verbose;
#		print "$outpath/$name.stat.groups.log.csv\n";
		open my $glog,'>',"$outpath/$name.stat.groups.log.csv" or die "Error, couldn't open csv for writing group log\n";
		open my $gfa_out, '>', "$outpath/$name.stat.groups.fa" or die "Error, couldn't open fa for writing\n";
	
		print $glog "group,n_sequences,min_length,max_length,mean_length,stdev_length\n";
		foreach my $gi (0..$#gids_sorted){
			print $glog "$gids_sorted[$gi],$stat_sorted[$gi],";
			my @out_lengths = @{${$groups}{$gids_sorted[$gi]}{lengths}};
			print $glog min(@out_lengths),",";
			print $glog max(@out_lengths),",";
			print $glog sum(@out_lengths)/@out_lengths,",";
			print $glog stdev(@out_lengths),"\n";
	
			print $gfa_out ">$gids_sorted[$gi];size=$stat_sorted[$gi]\n";
			print $gfa_out "${$groups}{$gids_sorted[$gi]}{seq}\n";
		}
	
		close $gfa_out;
		close $glog;
	} else {
		print "No sequences passed filtering, nothing to display\n";
	}
}

sub parse_parameters {
	my ($inmode, $inparams) = @_;
	my @itarray;
	my @paramarray;
	my $n_singleparams;
	die "Input parameters not single values, did you mean to use \"--mode eval\"?\n" unless $inmode eq "eval" or all { $_ =~ /^[^,-]*$/ } values %$inparams;
	foreach my $param (keys %$inparams){
		push @paramarray, $param;
		if($inmode eq "stat" or $inmode eq "batch"){
			push @itarray, [$inparams->{$param}];
		} elsif ($inmode eq "eval"){
			if ($inparams->{$param} =~ /^(\d+(\.\d+)?)-(\d+(\.\d+)?),(\d+(\.\d+)?)$/ ){
				my @values;
				my $curmax = $1;
				while ($curmax <= $3){
					push @values, $curmax;
					$curmax += $5;
				}
				push @itarray, \@values;
			} elsif($inparams->{$param} =~ /^[a-zA-Z]+(?:,[a-zA-Z]+)+$/){
				my @values = split ',',$inparams->{$param};
				push @itarray, \@values;
			} elsif($inparams->{$param} =~ /^[a-zA-Z]+$|^\d+(\.\d+)?$/){
				push @itarray, [$inparams->{$param}];
				$n_singleparams++;
				die "No parameter ranges given, did you mean to use \"--mode run\"?\n" if($n_singleparams == scalar keys %$inparams);
			} else {
				die "Could not successfully parse string given for $param\n";
			}
		} else {
			die "Argument passed to --mode not recognised, see \"$script --help\" for more information\n"
		}
	}
	
	my @allarray;
	
	NestedLoops(\@itarray, sub {push @allarray, [ @_ ]});
	
	my %iterhash;
	foreach my $it (0 .. $#allarray){
		$iterhash{$it+1} = {map { $paramarray[$_] => $allarray[$it][$_] } 0..$#paramarray};
	}
	return \%iterhash;
}

sub read_fasta {
	my ($fapathin) = @_;
	my %fasta;
	my $id;
	open my $fa_in, '<', $fapathin or die "Couldn't open $fapathin\n";
	while(my $row = <$fa_in>){
		chomp $row;
		if($row =~ /^>(.+)$/){
			$id = $1;
		} elsif($row =~ /^[ATCGNatcgn]+$/){
			$fasta{$id} .= $row;
		} else { die "Couldn't read fasta format in $fapathin" };
	}
	close $fa_in;
	return %fasta;
}

sub group {
	my ($fa,$specs) = @_;
#Sort all sequences in the fasta by length, so the sequence that initialises a group will always be the longest
	print "sorting sequences by size\n";
	my @ids = sort { length($fa->{$b}) <=> length($fa->{$a}) } keys %$fa;
	printf "%d sequences\n",scalar @ids;
	my %fa_grouped;
	my @group_ids;
	my $group_id;
	my $minlength_discarded = 0;
	print "start grouping\n";
	foreach my $i (0 .. $#ids){
		my $start = -1;
		if(length($fa->{$ids[$i]}) <= ${$specs}{minlength}){
			$minlength_discarded++;
		} else {
			foreach my $j (0 .. $#group_ids){ 
				if(${$specs}{nest}){
					{ no warnings 'uninitialized'; $start = index($fa_grouped{$group_ids[$j]}{seq},$fa->{$ids[$i]}); } # supresses warning that will arise for first sequence with no group to check against
				} else {
					$start = 0 if($fa_grouped{$group_ids[$j]}{seq} eq $fa->{$ids[$i]});
				}
				if($start>-1){
					$fa_grouped{$group_ids[$j]} = add_group($fa_grouped{$group_ids[$j]},$start, $ids[$i],$fa->{$ids[$i]});
					last;
				}
			}
			if($start == -1){
				$group_id++;
				$fa_grouped{$group_id} = new_group($ids[$i],$fa->{$ids[$i]}); 
				push @group_ids, $group_id;
			}
		}
	printf "processed %d/%d sequences, currently at %d groups\r",$i+1,scalar @ids,$group_id+1;
	}
	my $minsize_discarded = 0;
	print "Removing groups that are too small...";
	if(${$specs}{minsize}>1){
		foreach my $g (keys %fa_grouped){
			delete $fa_grouped{$g} and $minsize_discarded++ if($fa_grouped{$g}{size}<${$specs}{minsize});
		}
	}
	print "$minsize_discarded removed\n";
	return(\%fa_grouped,$minlength_discarded,$minsize_discarded);
}

sub new_group {
	my ($s_id,$s_seq) = @_;
	my %out = (
		seq => $s_seq,
		id  => $s_id,
		size => 1,
		maxlength => length($s_seq),
		lengths => [length($s_seq)],
		basefreq => [(1) x length($s_seq)],
		members => {
			$s_id => {
				start => 1,
				length => length($s_seq),
				}
			}
		);
	return \%out;
}

sub add_group {
	my($s_hash, $s_start,$s_id,$s_seq) = @_;
	$s_hash->{members}->{$s_id} = {
				start => $s_start+1,
				length => length($s_seq),
				};
	$s_hash->{size}++;
	push @{$s_hash->{lengths}}, length($s_seq);
	my @bases = ((0) x $s_start, (1) x length($s_seq), (0) x ($s_hash->{maxlength} - $s_start - length($s_seq)));
	@{$s_hash->{basefreq}} = pairwise {$a + $b} @bases, @{$s_hash->{basefreq}};
	return $s_hash;
}

sub filter_groups{
	my ($groups,$specs,$loghead,$blastthreads) = @_;
	
	my @gids = keys %$groups;
	my %groupsort;
	foreach my $g (@gids){
		$groupsort{$g} = $groups->{$g}{size};
	}
	
	my @stat_sorted = sort { $b <=> $a } values %groupsort;
	my @gids_sorted = sort { $groupsort{$b} <=> $groupsort{$a} } keys %groupsort;
	
	my %log;
	
	print "\nStarting filtering in order of group size (largest->smallest)\n" if $verbose;
	
	my $gselection=1;
	my $groupspooled=0;
	while(1){
		printf "\nAssessing group $gselection%s\n",$groupspooled>0 ? "(pool of $groupspooled)":"" if $verbose;
		if (!@stat_sorted){
			print "No sequences passed grouping parameters, entire sample discarded\n";
			@log{@$loghead} = ('nosequences',("NA") x 4,0);
			last;
		}
		
		#1: Bootstrap
		my $pvalue = bootstrap(${$specs}{bootstraps},@stat_sorted);
		
		print "Bootstrap value $pvalue against ${$specs}{pvalue} (max ${$specs}{pvalue_maxthreshold})\n" if $verbose;
		
		if($pvalue >= ${$specs}{pvalue_maxthreshold}){
			@log{@$loghead} = ('exceeded_max_pvalue','NA',$pvalue,$groupspooled,$gselection,$stat_sorted[0]);
			print "Group $gselection exceeded maximum pvalue, entire sample discarded\n" if $verbose;
			last;
		}elsif($pvalue <= ${$specs}{pvalue}){
			#2. BLAST
			my @blastbestguess = taxonomyblast(($groups->{$gids_sorted[0]}{seq}),$specs,$blastthreads);
			my %blast;
			if(!@blastbestguess){
				$log{blastwarning} = 1;
			} else {
				%blast = map { $_ => 1} @blastbestguess;
			}
			if(exists($blast{${$specs}{blasttarget}})){
				@log{@$loghead} = ('passed',$gids_sorted[0],$pvalue,$groupspooled,$gselection,$stat_sorted[0]);
				print "Group $gselection passed filter, done\n" if $verbose;
				last;
			}
		}
		
		if($#gids_sorted == 0){
			print "Group $gselection not sufficiently distinct or similar to target taxon. No further groups exist, entire sample discarded\n" if $verbose;
			@log{@$loghead} = ('groups_exhausted','NA',$pvalue,$groupspooled,$gselection,$stat_sorted[0]);
			last;
		}
		
		print "Group $gselection did not pass. Checking similarity to next-largest group to see if pooling groups is appropriate\n" if $verbose;
		#Calculate similarity
		my $muscle = `printf \">".$gids_sorted[0]."\\n".$groups->{$gids_sorted[0]}{seq}."\\n>".$gids_sorted[1]."\\n".$groups->{$gids_sorted[1]}{seq}."\\n\" | muscle 2> /dev/null`;
		my @muscleout = split("\n",$muscle);
		my $pc_id = identity($muscleout[1],$muscleout[3]);
		print "Groups are $pc_id identical, against criterion of ${$specs}{identity}\n" if $verbose;
		#Check similarity
		if ($pc_id >= ${$specs}{identity}) {
			print "Groups are similar enough, pooling together and starting again with the pooled group...\n" if $verbose;
			my $maxstat = shift @stat_sorted;
			my $maxgid = shift @gids_sorted;
			$stat_sorted[0] += $maxstat;
			$gids_sorted[0] = $maxgid;
			$groupspooled++;
		} else {
			print "Groups are not similar enough, discarding group $gselection and starting again with next-largest group...\n" if $verbose;
			shift @stat_sorted;
				shift @gids_sorted;
			$gselection+=1+$groupspooled;
			$groupspooled = 0;
		}
	}
	return(\%log)
}

sub bootstrap{
	my $boots = shift @_;
	my @values = @_;
	my $max = max(@values);
	my $ngroups = $#values+1;
	my $nseqs = sum(@values);
	
	print "Running $boots bootstraps placing $nseqs sequences randomly into $ngroups groups to find probability of group with $max members\n";
	
	my $nsuccesses = 0;
	foreach (1..$boots) {
		my %grp;
		$grp{int(rand($ngroups-1))+1}++ foreach (1..$nseqs);
		$nsuccesses++ if(max(values %grp) > $max);
	}
	
	return $nsuccesses/$boots;
}

sub taxonomyblast{
	my ($seq,$parameters,$blastthreads) = @_;
	print "Blasting\n" if $verbose;
	my $blastcmd = "blastn -query <(echo -e \">sample\\n$seq\") -db $blastpath -num_threads $blastthreads -max_target_seqs ${$parameters}{blasthits} -outfmt \"6 sacc bitscore\"";
	my $blastdump;
	my $blasttries = 0;
	while(!$blastdump && $blasttries<5){
		$blastdump = qx(bash -c '$blastcmd');
		$blasttries++;
	}
	my @out;
	if($blastdump){
		print "Retrieving taxonomy information\n" if $verbose;
		my @accessions = ($blastdump =~ /(?:^|\n)(\w+)/g);
		my $accessionstring = join ",",@accessions;
#		print $accessionstring,"\n";
		my $nucdump = get("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=$accessionstring&retmode=xml&rettype=fasta");
		my $taxidstring = join ",",($nucdump =~ /<TSeq_taxid>(.*)<\/TSeq_taxid/g);
#		print $taxidstring,"\n";
		my $taxdump = get("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&id=$taxidstring");
		my @lineages = ($taxdump =~ /<Lineage>(.*)<\/Lineage>/g);
		my @linaoa;
		foreach my $i (0..$#lineages){
			$linaoa[$i] = [ split /;\s/,$lineages[$i] ];
		}
	
		my $ti = -1;
		my @htind = (1..$#linaoa);
		while($ti < scalar @{$linaoa[0]}-1){
			$ti++;
			@htind = grep { $linaoa[$_][$ti] =~ $linaoa[0][$ti] } @htind;
			$ti-- and last if($#htind/$#linaoa <= ${$parameters}{blastthreshold});
		}
		@out = @{$linaoa[0]}[0..$ti];
	}
	return @out;
}


sub histogram {
	my($data,$bins) = @_;
	my @values = @$data;
	my $range = (1+max(@values))-(min(@values)-1);
	my $step = $range/$bins;
	my @lower_bounds;
	my @upper_bounds;
	my @frequencies;
	my @frequency_lengths;
	
	foreach my $i (0..($bins-1)){
	$lower_bounds[$i] = min(@values)-1+($i*$step);
	$upper_bounds[$i] = $lower_bounds[$i]+$step;
	my @within_bounds = grep { $_>$lower_bounds[$i] && $_<=$upper_bounds[$i] } @values;
	$frequencies[$i] = scalar @within_bounds;
	$frequency_lengths[$i] = length($frequencies[$i]);
	}
	my $longest_bin = length($upper_bounds[$#upper_bounds]);
	my $longest_value = max(@frequency_lengths);
	my $freq_scale = max(@frequencies)/50;
	foreach my $i (0..($bins-1)){
	printf('%*3$.0f->%*3$.0f|', $lower_bounds[$i],$upper_bounds[$i],$longest_bin);
	printf(' %*s', $longest_value, $frequencies[$i]);
	print " (";
	printf('%5.1f',($frequencies[$i]/sum(@frequencies))*100);
	print "%)|";
	print '#' x ceil($frequencies[$i]/$freq_scale);
	print "\n";
	}
}

sub stdev {
	my @data = @_;
	my $mean = sum(@data)/@data;
	my @deviations = map { ($_-$mean)**2 } @data;
	return sqrt( sum(@deviations)/@deviations );
}

sub identity {

	my($string1, $string2) = @_;

	# we assume that the strings have the same length
	my $length = length($string1);
	my $position;
	my $count = 0;
	my $gaps = 0;
	for ($position=0; $position < $length ; ++$position) {
		if(substr($string1,$position,1) eq substr($string2,$position,1)) {
			++$count;
		} elsif(substr($string1,$position,1) eq "-" || substr($string2,$position,1) eq "-"){
			++$gaps;
		}
	}

	return $count / ($length-$gaps);
}
