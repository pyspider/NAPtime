#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path remove_tree);
use List::Util qw(sum all any min max); 
use List::MoreUtils qw(pairwise);
use Algorithm::Loops qw(NestedLoops);
use POSIX;
use LWP::Simple;
use Parallel::ForkManager;
use Sys::Hostname;

####Dev####
use Data::Dumper;

my $version = "0.3.2"; #22/5/17

my $help;
my $outpath;
my %parameters;
my %blastparams =(
	blasthits => 25,
	assignsens => 0.25
);
my $mode;
my $threads = 1;
our $verbose;

my $script = basename($0,());

########################################################
# USAGE
#
my $usage =<<USAGE;

Description:

	This is $script version $version of the NGS Amplicon Pipeline. It carries out either barcode selection or clustering of one or several fastas. When selecting barcodes, there are three modes: viewing statistics for a single file, running one or several files in batch mode with a set of parameters, or iterating through range(s) of parameter(s) to explore parameter space. Clustering only has the latter two modes.
	
	For more details, see the google doc documentation.
	
USAGE
#
######################################################

GetOptions("output=s"		=> \$outpath,
	   "mode=s"		=> \$mode,
	   "minlength=s"	=> \$parameters{minlength},
	   "cluster_method=s"	=> \$parameters{cluster_method},
	   "filter_chimeras=s"	=> \$parameters{filter_chimeras},
	   "otuassign=s"	=> \$parameters{otuassign},
	   "minsize=s"		=> \$parameters{minsize},
	   "blastpath=s"	=> \$blastparams{blastpath},
	   "blasthits=s"	=> \$blastparams{blasthits},
	   "assignsens=s"	=> \$blastparams{assignsens},
	   "threads=i"		=> \$threads,
	   "verbose"		=> \$verbose,
	   "help"		=> \$help) or die "Error: Incorrect options, try \"$script --help\" for more information.\n";

#
# Check and do parsing of inputs
#
print "$usage\n" and exit if($help);

die "I need some files to work on, see \"$script --help\" for more information\n" if(scalar @ARGV == 0);
die "Error: minlength must be specified\n" unless(defined $parameters{minlength});
if(!defined $outpath){
	die "Error: output directory must be specified, see \"$script --help\" for more information\n";
} else {
	print "Creating output directory if needed\n" if $verbose;
	make_path($outpath);
	make_path("$outpath/temp/");
	$outpath =~ s/\/$//;
}

my @files=@ARGV;

#
# Check for blast database and arrange threads
#

if(!$blastparams{blastpath}){
	my $host = hostname;
	my %paths = (
		'ctag' => '/dh/blastdb/nt',
		'hpc-watson' => '/db/blastdb/nt'
	);
	if(exists($paths{$host})){
		$blastparams{blastpath} = $paths{$host};
	} else {
		die "Error: no path to BLAST database found, please give me one using --blastpath <path>\n";
	}
};
$blastparams{blastthreads} = $threads;


# Set defaults
$mode = "batch" unless(defined $mode);
my %paramdefaults = (
	'filter_chimeras'	=> 'no',
	'minsize'		=> 2,
	'cluster_method'	=> 'usearch',
	'otuassign'		=> 3,
);
my @params = keys %parameters;
@parameters{@params} = map { defined $parameters{$_} ? $parameters{$_} : $paramdefaults{$_} } (@params);

if($parameters{filter_chimeras} eq 'both'){
	$parameters{filter_chimeras} = "yes,no";
}elsif($parameters{filter_chimeras} eq 'no'){
	warn "\nWarning: cluster method \"swarm\" does no chimera filtering, it is advisable to use \"--filter_chimeras yes\"\n\n" if $parameters{cluster_method} eq "swarm";
}elsif($parameters{filter_chimeras} ne 'yes'){
	die "Error: value $parameters{filter_chimeras} passed to --filter_chimeras not recognised\n";
}

print "\nParameters parsed successfully, mode is \"$mode\"\n" if $verbose;


#
# Set up parameter iterations
#
my $iterations = parse_parameters($mode,\%parameters);
my @n_iter = sort keys %$iterations;

printf "%d iterations successfully parsed\n\n",$#n_iter+1 if($verbose and $#n_iter>0);


my %log;
my %otusets;
my %stats = (
	general => ['filename','sequences','iteration','n_seq_discarded_<minlength','n_groups','n_groups_discarded_<minsize','n_groups_remain'],
	group   => ['mean_groupsize','min_groupsize','max_groupsize'],
	cluster => ['n_otus','n_chimeras_uchime','n_chimeras_cluster']
);

#
# Read in files
#
print "Reading and concatenating all files\n" if $verbose;
my %allfasta;
foreach my $file (@files){
	my %fasta = read_fasta($file,"check");
#	printf "$file has %d sequences\n", scalar keys %fasta;
	warn "Warning: file $file is empty!\n" if(scalar keys %fasta < 1);
	@allfasta{keys %fasta} = values %fasta;
}

#	printf "Concatenation has %d sequences\n", scalar keys %allfasta;
#	die "Error, no sequences in any input fasta" if(scalar keys %allfasta<1);

#
# Do pipeline
#

my $pm = Parallel::ForkManager->new($threads);
my $done_iterations=0;

$pm->run_on_finish( sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
	$done_iterations++;
	printf "Completed $done_iterations/%d total iterations\r",($#n_iter+1) if $verbose and $mode eq 'eval';
	my $iter = $data_structure_reference->{iter};
	$log{$iter} = $data_structure_reference->{log};
	$otusets{$iter} = $data_structure_reference->{otus};
});

print "Starting clustering\n" if $verbose and $mode eq "batch";
printf "Starting %d clustering iterations using $threads threads \n", ($#n_iter+1) if $verbose and $mode eq "eval";

foreach my $iter (@n_iter){;
	my $pid = $pm->start and next;
	
	my ($log,$otus) = group_sort_and_cluster(\%allfasta,$iterations,$iter,\@params,\%stats);
	
	$pm->finish(0, {log => $log, otus => $otus, line => $iter});
}

$pm->wait_all_children;
print "\n";

#
# Process otus
#

print "BLASTing OTUs across all iterations and making best-guess taxonomies\n";

my %allotuseqs;
foreach my $iter (keys %otusets){
	foreach my $seq (keys %{$otusets{$iter}}){
		push(@{$allotuseqs{$seq}},"$iter,$otusets{$iter}{$seq}");
	}
}

my %seqstoblast;
@seqstoblast{0..scalar keys %allotuseqs} = keys %allotuseqs;

my %taxonomies = batch_taxonomyblast(\%seqstoblast,\%blastparams);

open my $taxout, '>', "$outpath/cluster.otus.taxonomy.txt";
print $taxout "iteration,otu_id,duplicate,taxonomy_lineage\n";
foreach my $id (keys %seqstoblast){
	my @duplicates = @{$allotuseqs{$seqstoblast{$id}}};
	foreach my $i (0..$#duplicates){
		print $taxout "$duplicates[$i],$i",join(";",@{$taxonomies{$id}}),"\n";
	}
}



#
# Output results log
#

open my $logcsv, '>', "$outpath/cluster.$mode.log.csv";

my @head = (@{$stats{general}},@params,@{$stats{group}},@{$stats{cluster}});

print $logcsv join(',',@head);

foreach my $i (keys %log){
	print $logcsv "\n",join(',',@{$log{$i}}{@head});
}

close $logcsv;

print "\nCleaning temporary files\n" if $verbose;
system "rm -rd $outpath/temp";

print "\nCSV log successfully written to $outpath/cluster.$mode.log.csv\n" if $verbose;

##TODO: implement swarm and associated functions


exit;

sub batch_taxonomyblast{
	my ($queryhash,$parameters) = @_;
	my $querypath = "tempblastfasta.fa";
	my @ids = keys %$queryhash;
	my %out;
	
	# output fasta
	open my $ofa, '>', "temp.fa";
	foreach my $id (keys %$queryhash){
		print $ofa ">$id\n${$queryhash}{$id}\n";
	}
	close $ofa;
	
	# blast
	my $blastcmd = "blastn -query $querypath -db ${$parameters}{blastpath} -num_threads ${$parameters}{blastthreads} -max_target_seqs ${$parameters}{blasthits} -outfmt \"6 sacc bitscore\"";
	my $blastdump;
	my $blasttries = 0;
	while(!$blastdump && $blasttries<5){
		$blasttries++;
		print "blasting $blasttries\n";
		$blastdump = qx(bash -c '$blastcmd');
	}
	
	if($blastdump){
		print "Retrieving taxonomy information\n";
		my @accessions = ($blastdump =~ /(?:^|\n)(\w+)/g);
		my $accessionstring = join ",",@accessions;
		my $nucdump = get("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=$accessionstring&retmode=xml&rettype=fasta");
		my $taxidstring = join ",",($nucdump =~ /<TSeq_taxid>(.*)<\/TSeq_taxid/g);
		my $taxdump = get("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&id=$taxidstring");
		my @lineages = ($taxdump =~ /<Lineage>(.*)<\/Lineage>/g);
		foreach my $n (0..$#ids){
			my @linaoa;
			my $min = $n*${$parameters}{blasthits};
			my $max = ($n+1)*${$parameters}{blasthits}-1;
			foreach my $i ($min..$max){
				push @linaoa,[ split /;\s/,$lineages[$i] ];
			}
			my $ti = -1;
			my @htind = (1..$#linaoa);
			while($ti < scalar @{$linaoa[0]}-1){
				$ti++;
				@htind = grep { $linaoa[$_][$ti] =~ $linaoa[0][$ti] } @htind;
				$ti-- and last if($#htind/$#linaoa <= ${$parameters}{assignsens});
			}
			$out{$ids[$n]} = [ @{$linaoa[0]}[0..$ti] ];
		}
	}
	
	system("rm $querypath");
	return \%out;
}

sub group_sort_and_cluster{
	my ($allfasta,$iterations,$iter,$params,$stats) = @_;
	my %log;
	
	printf "\nClustering iteration $iter of %d\n",scalar keys %$iterations if $verbose;
	#
	# Prepare paths
	#
	my $pathroot = "$outpath/temp/cluster.iteration$iter\_";
	
	my $allreadspath = $pathroot."allreads.fa";
	my $dereppath = $pathroot."derep.fa";
	my $sortpath = $pathroot."sort.fa";
	my $chimerapath = $pathroot."chimeras.fa";
	my $nonchimerapath = $pathroot."nonchimeras.fa";
	my $otuspath = $pathroot."otus.fa";
	my $ucpath = $pathroot."map.uc";
	my $mappath = $pathroot."map.csv";
	
	#
	# Write all sequences greater than minlength for later mapping
	#
	my $minlength_discarded;
	
	open my $allout, '>', $allreadspath or die "Error writing to $allreadspath\n";
	
	foreach my $id (keys %$allfasta){
		if(length(${$allfasta}{$id})>=${$iterations}{$iter}{minlength}){
			print $allout ">$id\n${$allfasta}{$id}\n";
		} else {
			$minlength_discarded++;
		}
	}
	close $allout;
	
	print "Discarded $minlength_discarded sequences for being too short\n";
	
	#
	# Group all sequences
	#
	print "Dereplicating all sequences longer than ${$iterations}{$iter}{minlength}bp\n" if $verbose;
	
	my $derep_cmd = "usearch80 -derep_fulllength $allreadspath -fastaout $dereppath -sizeout 2>&1";
#	print "Command: $derep_cmd\n";
	my $derep_log = `$derep_cmd`;
#	print "Log:\n$derep_log\n";
	$derep_log =~ /^.+\s(\d+)\sseqs,\s(\d+)\suniques,\s(\d+)\ssingletons.+size\s(\d+).+max\s(\d+),\savg\s(\d+(?:\.\d+)).+$/s;
	my ($inputseqs,$ngroup,$singletons,$minsize,$topsize,$mean_groupsize) = ($1,$2,$3,$4,$5,$6);
	
	#
	# Sort by size 
	#
	my $sort_cmd = "usearch80 -sortbysize $dereppath -fastaout $sortpath -minsize ${$iterations}{$iter}{minsize} 2>&1";
	my $sort_log = `$sort_cmd`;
	$sort_log =~ /\s(\d+)\ssequences/;
	my $n_groups_remain = $1;
	my $minsize_discarded = $ngroup-$n_groups_remain;
	
	print "$minlength_discarded sequences discarded for being less than ${$iterations}{$iter}{minlength}bp long, $inputseqs sequences dereplicated into $ngroup groups, of which $minsize_discarded discarded for having fewer than ${$iterations}{$iter}{minsize} members: clustering $n_groups_remain unique sequences\n" if $verbose;
	
	#
	# Do logging
	#
	@log{@{${$stats}{general}}} = ("Dereplicated concatenated samples", scalar keys %$allfasta, $iter, $minlength_discarded, $ngroup, $minsize_discarded, $n_groups_remain);
	@log{@{${$stats}{group}}} = ($mean_groupsize,$minsize,$topsize);
	@log{@$params} = @{${$iterations}{$iter}}{@$params};
	
	#
	# Perform clustering
	#
#	open my $fh, '>', "temp.txt";
		
	my ($n_chimeras_uchime,$clusterinput) = ("NA",$sortpath);
	if(${$iterations}{$iter}{filter_chimeras} eq "yes"){
		my $chimera_cmd = "usearch80 -uchime_denovo $sortpath -chimeras $chimerapath -nonchimeras $nonchimerapath 2>&1";
#		print "Command: $chimera_cmd\n";
		my $chimera_log = `$chimera_cmd`;
#		print $fh $chimera_log,"\n";

#		print "Log:\n$chimera_log\n";
		$chimera_log =~ /Writing\s(\d+)\schimeras/;
		$n_chimeras_uchime = $1;
#		print "uchime chimeras: $1\n";
		$clusterinput = $nonchimerapath;
	}
	
	my ($nOTUs,$n_chimeras_cluster);
	if(${$iterations}{$iter}{cluster_method} eq "usearch"){
		
		my $cluster_cmd = "usearch80 -cluster_otus $clusterinput -otus $otuspath -otu_radius_pct ${$iterations}{$iter}{otuassign} 2>&1";
#		print "Command: $cluster_cmd\n";
		my $cluster_log = `$cluster_cmd`;
#		print $fh $cluster_log,"\n";
#		print "Log:\n$cluster_log\n";
		$cluster_log =~ /.*\s(\d+)\sOTUs,\s(\d+)\schimeras/s; #.* at beginning of regex ensures last OTU and chimera values selected (the function prints multiple lines of progress using \r!)
#		print "cluster chimeras: $2\n";
		($nOTUs,$n_chimeras_cluster) = ($1,$2);
	} elsif(${$iterations}{$iter}{cluster_method} = "swarm"){
		
		my @bases = ('A','C','T','G');
		my $randbase = $bases[int(rand(4))];
		my $sed_cmd = "sed -i -e'/^>/ ! s/N/$randbase/g' $clusterinput";
		print $sed_cmd,"\n";
		system($sed_cmd);
		my $cluster_cmd = "swarm -z -t 1 -d ${$iterations}{$iter}{otuassign} -w $otuspath $clusterinput 2>&1";
		print $cluster_cmd,"\n";
		my $cluster_log = `$cluster_cmd`;
		print $cluster_log,"\n";
		$cluster_log =~ /Number\sof\sswarms:\s+(\d+)/;
		($nOTUs,$n_chimeras_cluster) = ($1,"NA");
	}
#	close $fh;
	print "Clustering using method \"${$iterations}{$iter}{cluster_method}\" completed successfully, $nOTUs otus found\n" if $verbose;
	
	#
	# Read OTUs to hash for output
	#
	
	my %otus = read_fasta($otuspath);
	my %otus_rev = map { $otus{$_} => $_ } keys %otus;
	
	#
	# Map OTUs
	#
	my $idpc;
	if(${$iterations}{$iter}{cluster_method} eq "usearch"){
		$idpc=1-(${$iterations}{$iter}{otuassign}/100);
	} else {
		$idpc = 0.97;
	}
	my $mapcmd = "usearch80 -usearch_global $allreadspath -db $otuspath -strand plus -id $idpc -uc $ucpath 2>&1";
#	print "Command: $mapcmd\n";
	my $maplog=`$mapcmd`;
#	print "Log:\n$maplog\n";
	convert_uc_and_write($ucpath,$mappath);
	
	#
	# Final logging and output
	#
	print "Reads successfully mapped to OTUs\n" if $verbose;
	if($mode eq 'batch'){
		system("mv $otuspath $outpath/otus_iteration$iter.fa");
		system("mv $mappath $outpath/map_iteration$iter.csv");
	}
	@log{@{${$stats}{cluster}}} = ($nOTUs,$n_chimeras_uchime,$n_chimeras_cluster);
	return (\%log,\%otus_rev);
}

sub parse_parameters {
	my ($inmode, $inparams) = @_;
	my @itarray;
	my @paramarray;
	my $n_singleparams;
	die "Input parameters not single values, did you mean to use \"--mode eval\"?\n" unless $inmode eq "eval" or all { $_ =~ /^[^,-]*$/ } values %$inparams;
	foreach my $param (keys %$inparams){
		push @paramarray, $param;
		if($inmode eq "stat" or $inmode eq "batch"){
			push @itarray, [$inparams->{$param}];
		} elsif ($inmode eq "eval"){
			if ($inparams->{$param} =~ /^(\d+(\.\d+)?)-(\d+(\.\d+)?),(\d+(\.\d+)?)$/ ){
				my @values;
				my $curmax = $1;
				while ($curmax <= $3){
					push @values, $curmax;
					$curmax += $5;
				}
				push @itarray, \@values;
			} elsif($inparams->{$param} =~ /^[a-zA-Z]+(?:,[a-zA-Z]+)+$/){
				my @values = split ',',$inparams->{$param};
				push @itarray, \@values;
			} elsif($inparams->{$param} =~ /^[a-zA-Z]+$|^\d+(\.\d+)?$/){
				push @itarray, [$inparams->{$param}];
				$n_singleparams++;
				die "No parameter ranges given, did you mean to use \"--mode run\"?\n" if($n_singleparams == scalar keys %$inparams);
			} else {
				die "Could not successfully parse string given for $param\n";
			}
		} else {
			die "Argument passed to --mode not recognised, see \"$script --help\" for more information\n"
		}
	}
	
	my @allarray;
	
	NestedLoops(\@itarray, sub {push @allarray, [ @_ ]});
	
	my %iterhash;
	foreach my $it (0 .. $#allarray){
		$iterhash{$it+1} = {map { $paramarray[$_] => $allarray[$it][$_] } 0..$#paramarray};
	}
	return \%iterhash;
}

sub read_fasta {
	my ($fapathin,$checklabel) = @_;
	my %fasta;
	my $id;
	my ($name,$dir)=fileparse($fapathin);
	$name =~ s/^(.+)\.[^.]+$/$1/;
	my $barcodelabelsadded;
	open my $fa_in, '<', $fapathin or die "Couldn't open $fapathin\n";
	while(my $row = <$fa_in>){
		chomp $row;
		if($row =~ /^>(.+)$/){
			$id = $1;
			if($checklabel and !($id =~ /;barcodelabel=\w+;/)){
				$barcodelabelsadded++;
				$id.=";barcodelabel=$name;";
			}
			$id =~ s/\s/_/g;
		} elsif($row =~ /^[ATCGNatcgn]+$/){
			$fasta{$id} .= $row;
		} else { die "Couldn't read fasta format in $fapathin" };
	}
	close $fa_in;
	print "File $fapathin missing barcode labels, \";barcodelabel=$name;\" appended to header of $barcodelabelsadded sequences\n" if $checklabel and $barcodelabelsadded and $verbose;
	return %fasta;
}

sub convert_uc_and_write {
	my ($ucpath,$outpath) = @_;
	my %tab;
	my %samples;
	my %otus;
	open my $uc, '<', $ucpath or die "Error opening $ucpath\n";
	while(my $row = <$uc>){
		chomp $row;
		if($row =~ /H.*barcodelabel=(\w+);\t(.*)$/){
			$tab{$1}{$2}++;
			$samples{$1}=1;
			$otus{$2}=1;
		}
	}
	close $uc;
	open my $csv, '>', $outpath or die "Error opening $outpath\n";
	print $csv "sample,",join(",",sort keys %otus),"\n";
	foreach my $sample (sort keys %samples){
		print $csv $sample;
		foreach my $otu (sort keys %otus){
			print $csv ",",$tab{$sample}{$otu} ? $tab{$sample}{$otu} : 0;
		}
		print $csv "\n";
	}
	close $csv;
}
